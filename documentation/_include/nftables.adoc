:sectnums:
:sectnumlevels: 3
:markup-in-source: verbatim,attributes,quotes
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:format_cmd_exec: source,options="nowrap",subs="{markup-in-source}",role="copy"
:format_cmd_output: bash,options="nowrap",subs="{markup-in-source}"
ifeval::["%cloud_provider%" == "ec2"]
:format_cmd_exec: source,options="nowrap",subs="{markup-in-source}",role="execute"
endif::[]



:toc:
:toclevels: 1

= Introducing NFTables

== Overview

NFTables is the subsystem of the Linux kernel which provides filtering and classification of network packets, datagrams, or frames. This software provides an in-kernel packet classification framework that is based on a network-specific Virtual Machine (VM) and a new nft userspace command line tool.

Primary benefits:

  * Better performance
  * Better usability

=== History

Without getting too technical on a VERY technical topic, let it be known that a network packet flows through a complex series of rules in the linux kernel known as the 'netfilter'.  How those rules are established and maintained is done through a set of tools which have been updated and replaced from time to time.

Significant changes include:

  * ip-firewall (linux kernel v2.0, managed with ipfwadm)
  * ip-chains (linux kernel v2.2, managed with ipchains)
  * ip-tables (linux kernel v2.4, managed with iptables)
  * nf-tables (linux kernel v3.13, managed with nft)

=== Recommended Usage

In which scenario should you use one of the following?

  * *firewalld*: for simple firewall use cases. It is easy to use and covers the typical use cases.
  * *nftables*: for complex and performance critical firewalls.
  * *iptables*: Red Hat Enterprise Linux uses the nf_tables kernel API instead of the legacy back end, thus the nf_tables API provides backward compatibility so that scripts that use iptables commands still work. For new firewall scripts, Red Hat recommends to use nftables.

The default firewall management tool in RHEL 9 continues to be firewalld _(firewall-cmd)_, which gained support for nftables with version 0.6.0.

NOTE: For 99% of all use cases the firewalld tools are the best choice.  For this lab however we are trying to introduce `nft` and demonstrate some differences to the former `iptables`.


== Getting Started

For these exercises, you will be using the host `node2` as user `root`.

From host `bastion`, ssh to `node2`.

[{format_cmd_exec}]
----
*ssh node2*
----

Use `sudo` to elevate your privileges.

[{format_cmd_exec}]
----
*sudo -i*
----

Verify that you are on the right host for these exercises.

[{format_cmd_exec}]
----
*workshop-nftables-checkhost.sh*
----

You are now ready to proceed with these exercises.

== Disable Firewalld


[{format_cmd_exec}]
----
*systemctl disable firewalld --now*
----

[{format_cmd_exec}]
----
*systemctl enable nftables --now*
----


== nft Fundamentals


=== Tables

Tables are the top-level construct within the nftables ruleset.

A table consists of:

  * *chains*
  * *sets*
  * *maps*
  * *flowtables*
  * *stateful objects*

Each table belongs to exactly one family:

  * *ip* - IPv4
  * *ip6* - IPv6
  * *inet* - both IPv4 and IPv6
  * *arp* 
  * *bridge*
  * *netdev*

So your ruleset requires at least one table for each family you want to filter.

Using nft, show the current state of the network tables.

[{format_cmd_exec}]
----
*nft list tables*
----

There is nothing there, so let us create a new table called 'filter'

[{format_cmd_exec}]
----
*nft add table inet filter*
----

[{format_cmd_exec}]
----
*nft list tables*
----


[{format_cmd_output}]
----
table inet filter
----

=== Chains



Using nft, show the current state of the network chains.

[{format_cmd_exec}]
----
*nft list chains*
----

[{format_cmd_output}]
----
table inet firewalld {
        chain mangle_PREROUTING {
                type filter hook prerouting priority mangle + 10; policy accept;
        }
        chain mangle_PREROUTING_POLICIES_pre {
        }
        chain mangle_PREROUTING_ZONES {
        }
        chain mangle_PREROUTING_POLICIES_post {
        }
        chain nat_PREROUTING {
                type nat hook prerouting priority dstnat + 10; policy accept;
        }
        chain nat_PREROUTING_POLICIES_pre {
        }
        chain nat_PREROUTING_ZONES {
        }
        chain nat_PREROUTING_POLICIES_post {
        }
}
...<snip>...
----

NOTE: The output for this can be VERY long.  You can optionally use `nft list chains | less` if you would like a pageable view of the output.


So what you have seen so far is the table and chains within that were created by firewalld.



== Add Single Rule

[{format_cmd_exec}]
----
*nft insert rule ip firewalld INPUT tcp dport http accept*
----

Verify the rule change.

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table ip filter { # handle 1
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
                tcp dport http accept # handle 4
        }

        chain FORWARD { # handle 2
                type filter hook forward priority 0; policy accept;
        }

        chain OUTPUT { # handle 3
                type filter hook output priority 0; policy accept;
        }
}
----

Remember the rule handle, we will use it next to delete the rule

== Delete Single Rule

[{format_cmd_exec}]
----
*nft delete rule filter INPUT handle 4*
----

Verify the rule change.

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table ip filter { # handle 1
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
        }

        chain FORWARD { # handle 2
                type filter hook forward priority 0; policy accept;
        }

        chain OUTPUT { # handle 3
                type filter hook output priority 0; policy accept;
        }
}
----


== Add Multiple Rules at Once

[{format_cmd_exec}]
----
*nft insert rule ip filter INPUT tcp dport { ssh, http, https, 8181 } accept*
----

Verify the new rules.

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table ip filter { # handle 1
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
                tcp dport { ssh, http, https, 8181 } accept # handle 6
        }

        chain FORWARD { # handle 2
                type filter hook forward priority 0; policy accept;
        }

        chain OUTPUT { # handle 3
                type filter hook output priority 0; policy accept;
        }
}
----

== Increase Network Security

WARNING: DO NOT do this step unless you successfully completed "Add Multiple Rules at Once" above.  You will get locked out of your network connection to node2.example.com if you have not.

Set the INPUT chain default policy to drop all traffic not specifically accepted.

[{format_cmd_exec}]
----
*nft add chain ip filter INPUT { type filter hook input priority 0\; policy drop\; }*
----

Verify Increased Security

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table ip filter { # handle 1
        chain INPUT { # handle 1
                type filter hook input priority 0; policy drop;
                tcp dport { ssh, http, https, 8181 } accept # handle 6
        }

        chain FORWARD { # handle 2
                type filter hook forward priority 0; policy accept;
        }

        chain OUTPUT { # handle 3
                type filter hook output priority 0; policy accept;
        }
}
----

== Cleanup

Remove rules added during this exercise.  We begin by setting the INPUT chain default policy to accept all traffic.

[{format_cmd_exec}]
----
*nft add chain ip filter INPUT { type filter hook input priority 0\; policy accept\; }*
----

Now find the handle and remove the rule currently allowing access for SSH, HTTP, HTTPS, and 8181

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table ip filter { # handle 1
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
                tcp dport { ssh, http, https, 8181 } accept # handle 6
        }

        chain FORWARD { # handle 2
                type filter hook forward priority 0; policy accept;
        }

        chain OUTPUT { # handle 3
                type filter hook output priority 0; policy accept;
        }
}
----

In the output above, we determine the handle for our rule is '6'.

[{format_cmd_exec}]
----
*nft delete rule filter INPUT handle 6*
----

NOTE: You can also use the 'flush' option to clear an entire table: `nft flush table ip filter`

Verify that everything is back to normal

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table ip filter { # handle 1
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
        }

        chain FORWARD { # handle 2
                type filter hook forward priority 0; policy accept;
        }

        chain OUTPUT { # handle 3
                type filter hook output priority 0; policy accept;
        }
}
----

== Additional Resources

You can find more information:

  * link:https://netfilter.org/projects/nftables[Project Page]
  * link:https://en.wikipedia.org/wiki/Nftables[Wikipedia NFTables]
  * link:https://wiki.nftables.org/wiki-nftables/index.php/Main_Page[NFTables How-To]
  * link:https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes[Quick Reference]
  * link:https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/configuring_firewalls_and_packet_filters/getting-started-with-nftables_firewall-packet-filters[Getting started with nftables]

[discrete]
== End of Unit

ifdef::env-github[]
link:../RHEL9-Workshop.adoc#toc[Return to TOC]
endif::[]

////
Always end files with a blank line to avoid include problems.
////
